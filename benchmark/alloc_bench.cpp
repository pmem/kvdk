#include <random>
#include <algorithm>
#include <vector>
#include <deque>
#include <iostream>
#include <map>
#include <string>
#include <chrono>
#include "../engine/pmem_allocator.hpp"
#include "../engine/kv_engine.hpp"
#include "../engine/thread_manager.hpp"
#include "kvdk/engine.hpp"
#include "kvdk/namespace.hpp"

uint64_t size_allocated(const std::deque<kvdk::SizedSpaceEntry>& entries)
{
	uint64_t sum = 0;
	for(auto const& entry : entries)
		sum+=entry.size;
	return sum;
}

constexpr uint64_t KB = 1<<10;
constexpr uint64_t MB = 1<<20;
constexpr uint64_t GB = 1<<30;
constexpr double load_factor = 0.8;

int main()
{
	std::mt19937 re{42};
	// Mean value of variable generated by gamma distribution is alpha * beta
	// alpha is shape parameter and beta is scale parameter.
	// For alpha = 1, gamma distribution becomes exponential distribution.
	uint64_t n_alloc = 16*MB;
	uint64_t sz_avg_alloc = 1024;
	double alpha = 2;
	// std::gamma_distribution<> dist{ alpha,static_cast<double>(sz_avg_alloc)/alpha };
	std::uniform_real_distribution<> dist{ 64,4096 };
	uint64_t sz_max = n_alloc * sz_avg_alloc;	// Allocate approximately 16GB
	
	kvdk::Engine* engine;
	kvdk::Status status;
	kvdk::Configs engine_configs;
	{
		engine_configs.pmem_file_size = sz_max;
		engine_configs.pmem_segment_blocks = 1024 * 1024;
		engine_configs.pmem_block_size = 64;
		engine_configs.populate_pmem_space = false;
		engine_configs.max_write_threads = 48;
	}

	std::string engine_path{ "/mnt/pmem0/bench_allocator" };
	int sink = system(std::string{ "rm -rf " + engine_path + "\n" }.c_str());

	status = kvdk::Engine::Open(engine_path, &engine, engine_configs, stdout);
	if (status == kvdk::Status::Ok)
		printf("Successfully opened a KVDK instance.\n");
	else
		return -1;

	std::shared_ptr<kvdk::PMEMAllocator> pmem_alloc = reinterpret_cast<KVDK_NAMESPACE::KVEngine*>(engine)->pmem_allocator_;
	reinterpret_cast<KVDK_NAMESPACE::KVEngine*>(engine)->thread_manager_->MaybeInitThread(KVDK_NAMESPACE::local_thread);

	std::deque<kvdk::SizedSpaceEntry> deq_entries;

	uint64_t sz_segment = engine_configs.pmem_segment_blocks * engine_configs.pmem_block_size;

	std::deque<uint64_t> deq_sz;
	for (size_t i = 0; i < n_alloc; i++)
	{
		uint64_t sz = static_cast<uint64_t>(dist(re));
		// Don't allocate spaces too large or too small
		// Too small will cause many inner fragmentation
		// Too large will fail the allocation
		// while (sz > (sz_segment/2) || sz < engine_configs.pmem_block_size)
		// 	sz = static_cast<uint64_t>(dist(re));
		deq_sz.push_back(sz);
	}


	std::chrono::high_resolution_clock clock;
	auto start = clock.now();
	auto end = clock.now();
	std::chrono::duration<double> elapsed_seconds = end-start;

	uint64_t sz_total = 0;
	uint64_t ind_last = 0;
	uint64_t ind_first = 0;
	for (int i = 0; i < 100; i++)
	{	
		std::cout<<"Allocate then free, iteration:\t"<<i+1<<"\n";

		start = clock.now();
		while (true)
		{
			if(ind_last==9954591)
			{
				std::cout<<"Break point for debugging!"<<std::endl;
			}
			auto sz = deq_sz[ind_last % deq_sz.size()];
			auto entry = pmem_alloc->Allocate(sz);
			if (entry.size==0)
			{
				std::cout << "Allocation failed!\n";
				break;
			}
			sz_total += sz;
			++ind_last;
			deq_entries.push_back(entry);
			if (static_cast<double>(sz_total)/static_cast<double>(sz_max) > load_factor)
				break;
		}
		end = clock.now();
		elapsed_seconds = end - start;
		std::cout 
			<< "elapsed time:\t" << elapsed_seconds.count() << "s\t"
			<< "allocations:\t" << deq_entries.size() << "\t"
			<< "total size:\t" << sz_total / MB << " MB\t"
			<< "total entries:\t" << size_allocated(deq_entries) / KB << " K\n";

		start = clock.now();
		for (size_t i = 0; i < n_alloc/5; i++)
		{
			if (deq_entries.empty())
				break;
			pmem_alloc->Free(deq_entries.front());
			deq_entries.pop_front();
			auto sz = deq_sz[ind_first % deq_sz.size()];
			sz_total -= sz;
			++ind_first;
		}
		end = clock.now();
		elapsed_seconds = end - start;
		std::cout 
			<< "elapsed time:\t" << elapsed_seconds.count() << "s\t"
			<< "allocations:\t" << deq_entries.size() << "\t"
			<< "total size:\t" << sz_total / (1ull << 20) << " MB\t"
			<< "total entries:\t" << size_allocated(deq_entries) / (1ull << 10) << " K\n";
	}

	return 0;
}